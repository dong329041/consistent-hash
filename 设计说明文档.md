# 一致性哈希原理

关于一致性哈希的原理及过程，请移步：[一致性 hash 算法释义](https://www.cnblogs.com/haippy/archive/2011/12/10/2282943.html)

---

# 代码思路解释

### 数据结构

在程序一开始的地方，定义了一个 HashRing 的指针 GHashRing，该指针变量作为该包内操作哈希环的唯一全局变量，采用单例模式设计。

HashRing 结构体代表哈希环，下面解释各个字段含义：
- ring：用一个 map 结构来表示，该 map 的 key 表示虚拟节点的 hash 值，value 为该虚拟节点所在的物理节点 ip（故可以从虚拟节点 hash 直接得到物理节点 ip）；
- sortedRing：将 ring 这个 map 中的 key（虚拟节点的 hash 值）排序成一个 uint32 的数组：
    - 该数组实现 sort.go 中的接口，以便调用 Sort() 进行排序（当数组元素大于 12 个时使用快速排序，当数组长度 ≤ 12 时使用希尔排序）
    - 在计算一个 string 映射到哪个节点上时，必须要根据这个有序的虚拟节点 hash 环，才能确定这个 string 的 hash 值位于哪两个虚拟节点 hash 值之间
- members：用一个 map 结构来表示，key 是真实节点的 ip 地址（只要存在一个 key，那么这个节点就在哈希环上），value 为 bool（true 表示这个成员处于正常状态，false 表示这个节点宕机了，无法访问，具体逻辑需要调用方来定义）
- weights：用一个 map 结构来表示，key 是真实节点的 ip 地址，value 是该节点的比重值（value 需要调用方来定义，可根据节点的存储容量等等）
- numberOfCubes：代表该哈希环上，一个真实节点复制为多少个虚拟节点（复制因子）
- sync.RWMutex：读写锁（对该哈希环进行操作时需要加锁，添加、删除结点时需要调用 Lock() 不允许读写，当调用 GetNode 计算 key 对应的虚拟节点时加读锁，可以并发读）

### 方法、函数解释

1. **InitHashRing**：用来初始化 HashRing，若之前已经存在 HashRing 变量，则会将其覆盖（因为创建的 HashRing 结构体的地址都要通过 GHashRing 这个指针来访问，单例模式）；
2. **GetHashRing**：返回 GHashRing 指针用于操作哈希环，若该指针为 nil（也就是哈希环结构体并未创建），则会创建该结构体，并将结构体地址赋给全局指针 GHashRing
3. **SetCubeNumber**：设置 HashRing 结构体中的 numberOfCubes，虚拟 cube 的数量必须在环中未加入节点前修改（因为环中添加了节点，再修改 cube 数量时，那么之前已经定位在环中的 key 将会失效，需要大量迁移）
4. **Members**：获取 HashRing 中的物理节点成员
5. **generateKey**：根据物理节点 ip 和虚拟 cube 的下标来生成 key；
6. **generateHash**：生成上面 key 对应的 hash 值；
7. **AddNode**：添加一个物理节点到哈希环上（将该物理节点的虚拟 cube 全部添加到哈希环上）；
8. **AddNodes**：添加多个物理节点到哈希环上（这是一次性将多个物理节点的虚拟 cube 全部添加到环上，然后触发所有虚拟 cube 的排序）
9. **RemoveNode**：从哈希环上移除一个物理节点（这个物理节点对应的 cube 全部被移除）；
10. **GetNode**：获取一个字符串需要映射到哪一个物理节点上（调用 search 获取离该字符串 hash 值最接近的虚拟 cube，然后查询  ring 这个 map 得到该虚拟 cube 对应的物理节点）；
11. **GetNodes**：获取一个字符串需要映射到的 n 个物理节点上（可用于多副本）（先按照 GetNode 方法得到第一个虚拟 cube，然后从这个 cube 开始在哈希环上顺时针依次查找，查找到与该虚拟 cube 对应物理节点不同的物理节点）；
12. **search**：查找一个字符串的 hash 值位于哪两个虚拟 cube 的 hash 值之间，然后返回这两个 hash 中较大的那个；
13. **updateSortedRing**：维护 HashRing 结构体中 sortedRing 数组的顺序（每次添加、移除节点时都会将环上的虚拟 cube 重新进行排序）（由于自定义类型 uintArray 实现了 sort.go 中的接口，所以可以使用 sort 中的 Sort 排序）
14. **sliceHasMember**：判断一个 slice 中是否包含此 member。

---

# 测试

### 测试 key 的映射情况（TestHashRing_GetNode）

向哈希环上添加 10 个物理节点（192.168.1.1 — 192.168.1.10），各节点比重依次设为 1、2、3 …… 10。
分别用 key1 — key5 这五个字符串来测试，映射到的物理节点如下：
```
testGet := []struct {
	in, out string
}{
	{"key1", "192.168.1.3"},
	{"key2", "192.168.1.7"},
	{"key3", "192.168.1.7"},
	{"key4", "192.168.1.9"},
	{"key5", "192.168.1.10"},
}
```

将 192.168.1.10 这个节点移除，再次用 key1 — key5 这五个字符串进行测试，映射到的物理节点如下：
```
testGetAfterRemove := []struct {
	in, out string
}{
	{"key1", "192.168.1.3"},
	{"key2", "192.168.1.7"},
	{"key3", "192.168.1.7"},
	{"key4", "192.168.1.9"},
	{"key5", "192.168.1.3"},
}
```

可以发现，只有 key5 之前映射到 192.168.1.10，现在由于该节点移除，被映射到了 192.168.1.3，其余的 key 都没有改变，也就是说只有被移除的节点所对应的 key 需要迁移，其他 key 不需要迁移，达到了一致性哈希的效果。


### 测试 key 分散的均匀性（TestHashRing_Dispersion）

同样的节点和比重（192.168.1.1 — 192.168.1.10，各节点比重依次设为 1、2、3 …… 10）。
将 key0 — key9999 这一万个映射到哈希环上，然后统计 10 个物理节点上分别得到了多少个 key，结果如下：

```
["192.168.1.1"] = 130
["192.168.1.2"] = 366
["192.168.1.3"] = 463
["192.168.1.4"] = 623
["192.168.1.5"] = 987
["192.168.1.6"] = 1009
["192.168.1.7"] = 1465
["192.168.1.8"] = 1333
["192.168.1.9"] = 1578
["192.168.1.10"] = 2046
```

由于 10 个物理节点的比重依次为 1 — 10，所以各物理节点上的分布还是比较均匀的。

### 详细测试

详细测试参见 [consistent_test.go](https://github.com/dong329041/consistentHash/blob/master/consistentHash_test.go)
